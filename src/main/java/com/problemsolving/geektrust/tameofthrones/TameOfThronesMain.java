/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.problemsolving.geektrust.tameofthrones;

import com.google.common.collect.ImmutableList;
import com.google.common.primitives.Bytes;
import com.problemsolving.geektrust.tameofthrones.model.Kingdom;
import com.problemsolving.geektrust.tameofthrones.util.CaesarCipher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

public class TameOfThronesMain {
    static Logger LOGGER = LoggerFactory.getLogger(TameOfThronesMain.class.getSimpleName());

    public static void main(String[] args) throws Exception {
        LOGGER.debug("Arguments are : {}", args);
        if (args.length == 0) throw new Exception("Please specify file with commands.");
        TameOfThronesMain instance = new TameOfThronesMain();
        System.out.println(args.length == 1 ? instance.processInputFromFile(args[0]) : instance.processInputFromCli(args));
    }

    public String processInputFromFile(String inputFilePath) throws IOException {
        return processMessages(getInput(inputFilePath));
    }

    public String processInputFromCli(String[] inputsFromCli) throws Exception {
        if (inputsFromCli.length < 6)
            throw new Exception("Please specify commands in the format: kingdom1 msg1 kingdom2 msg2 kingdom3 msg3");
        return processMessages(ImmutableList.of(
                String.join(" ", inputsFromCli[0], inputsFromCli[1]),
                String.join(" ", inputsFromCli[2], inputsFromCli[3]),
                String.join(" ", inputsFromCli[4], inputsFromCli[5])
        ));
    }

    public String processMessages(List<String> inputs) throws IOException {
        LOGGER.debug("Messages from kingdoms : {}", inputs);
        if (inputs.size() < 3) return "NONE";
        Set<String> allies = inputs.stream()
                .map(str -> new String[]{str.substring(0, str.indexOf(" ")), str.substring(str.indexOf(" ") + 1).replace(" ", "")})
                .map(array -> {
                    array[1] = CaesarCipher.decrypt(array[1], CaesarCipher.getCipher(Kingdom.valueOf(array[0]).getEmblem()));
                    return array;
                })
                .filter(this::checkMessageMatching)
                .map(strings -> strings[0])
                .collect(Collectors.toCollection(LinkedHashSet::new));
        return allies.size() > 2
                ? Kingdom.SPACE.name() + " " + String.join(" ", allies)
                : "NONE";
    }

    private List<String> getInput(String inputFilePath) throws IOException {
        List<String> strings = Files.readAllLines(Paths.get(inputFilePath));
        LOGGER.debug("Messages extracted from file : {}", strings);
        return strings;
    }

    private Boolean checkMessageMatching(String[] message) {
        Map<String, Long> emblemChars = Bytes.asList(Kingdom.valueOf(message[0]).getEmblem().name().getBytes()).stream()
                .map(Object::toString).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        Map<String, Long> msgChars = Bytes.asList(message[1].getBytes()).stream()
                .map(Object::toString).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        return emblemChars.entrySet().stream()
                .filter(entry -> msgChars.containsKey(entry.getKey()))
                .filter(entry -> msgChars.get(entry.getKey()) >= entry.getValue())
                .count() == emblemChars.size();
    }

}
